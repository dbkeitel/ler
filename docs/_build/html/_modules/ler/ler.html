<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ler.ler &mdash; ler 0.2.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ler
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Unlensed%20events.html">Unlensed events</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Lensed%20events.html">Lensed events</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/ler/ler/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.ler</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/ler/source_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.source_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/ler/lens_galaxy_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.lens_galaxy_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/ler/multiprocessing_routine/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.multiprocessing_routine</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/ler/helperroutines/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.helperroutines</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Rate%20comparision.html">Calculation of unlensed and lensed rate of detectable events</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ler.ler</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ler.ler</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the main class for calculating the rates of lensed and unlensed events.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">gwsnr</span> <span class="kn">import</span> <span class="n">GWSNR</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">gaussian_kde</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">astropy.cosmology</span> <span class="kn">import</span> <span class="n">Planck18</span>
<span class="kn">from</span> <span class="nn">ler.lens_galaxy_population</span> <span class="kn">import</span> <span class="n">LensGalaxyPopulation</span>
<span class="kn">from</span> <span class="nn">ler.source_population</span> <span class="kn">import</span> <span class="n">CompactBinaryPopulation</span>
<span class="kn">from</span> <span class="nn">ler.helperroutines</span> <span class="kn">import</span> <span class="n">append_json</span><span class="p">,</span> <span class="n">get_param_from_json</span>

<span class="c1"># Conversions from SI units to CGS units</span>
<span class="n">C</span> <span class="o">=</span> <span class="mf">299792458.0</span>  <span class="c1"># m/s</span>
<span class="n">G</span> <span class="o">=</span> <span class="mf">6.67408</span> <span class="o">*</span> <span class="mf">1e-11</span>  <span class="c1"># m^3/kg/s^2</span>


<div class="viewcode-block" id="LeR"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR">[docs]</a><span class="k">class</span> <span class="nc">LeR</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to calculate both the rates of lensed and unlensed events.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamples : `int`</span>
<span class="sd">        number of samples for sampling.</span>
<span class="sd">        default nsamples = 100000.</span>
<span class="sd">    npool : `int`</span>
<span class="sd">        number of cores to use.</span>
<span class="sd">        default npool = 4.</span>
<span class="sd">    z_min : `float`</span>
<span class="sd">        minimum redshift.</span>
<span class="sd">        default z_min = 0.</span>
<span class="sd">        for popI_II, popIII, primordial, BNS z_min = 0., 5., 5., 0. respectively.</span>
<span class="sd">    z_max : `float`</span>
<span class="sd">        maximum redshift.</span>
<span class="sd">        default z_max = 10.</span>
<span class="sd">        for popI_II, popIII, primordial, BNS z_max = 10., 40., 40., 2. respectively.</span>
<span class="sd">    batch_size : `int`</span>
<span class="sd">        batch size for SNR calculation.</span>
<span class="sd">        default batch_size = 25000.</span>
<span class="sd">        reduce the batch size if you are getting memory error.</span>
<span class="sd">    snr_finder : `str`</span>
<span class="sd">        default snr_finder = &#39;gwsnr&#39;.</span>
<span class="sd">        if &#39;gwsnr&#39;, the SNR will be calculated using the gwsnr package.</span>
<span class="sd">        if &#39;custom&#39;, the SNR will be calculated using a custom function.</span>
<span class="sd">    json_file_ler_param: `str`</span>
<span class="sd">        default json_file_ler_param = &#39;ler_param.json&#39;.</span>
<span class="sd">        json file containing the parameters for initializing the :class:`~ler.LeR` class, :class:`~ler.CompactBinaryPopulation` class, :class:`~ler.LensGalaxyPopulation` class, :class:`~gwsnr.GWSNR` class.</span>
<span class="sd">    kwargs : `keyword arguments`</span>
<span class="sd">        Note : kwargs takes input for initializing the :class:`~ler.CompactBinaryPopulation`, :class:`LensGalaxyPopulation`, :meth:`~gwsnr_intialization`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ----------</span>
<span class="sd">    - class initialization</span>
<span class="sd">    - ``ler`` needs `gwsnr &lt;https://github.com/hemantaph/gwsnr/&gt;`_.</span>
<span class="sd">    - generation of ``gwsnr`` snr interpolator will take time at the first initialization. The interpolator will be stored in the working dir.</span>
<span class="sd">    - ``m_min``, ``m_max`` were used for initializing the ``CompactBinaryPopulation`` class. ``waveform_approximant`` was used for initializing the ``snr_calculator`` (``gwsnr``) class. ``min_lensed_images`` was used for initializing the ``LensGalaxyPopulation`` class.</span>

<span class="sd">    &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">    &gt;&gt;&gt; ler_ = LeR(nsamples=100000, npool=int(4), z_min=0., z_max=10., batch_size=25000, snr_finder=&#39;gwsnr&#39;, m_min=4.59, m_max=86.22, waveform_approximant=&#39;IMRPhenomD&#39;, min_lensed_images=2)</span>
<span class="sd">    Given: IMR waveform</span>
<span class="sd">    psds not given. Choosing bilby&#39;s default psds</span>
<span class="sd">    getting stored interpolator...</span>
<span class="sd">    In case if you need regeneration of interpolator of the given gwsnr param, please delete this file, ./interpolator_pickle/halfSNR_dict_0.pickle</span>

<span class="sd">    Instance Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following attributes, \n</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    | Atrributes                          | Type                             |</span>
<span class="sd">    +=====================================+==================================+</span>
<span class="sd">    |:attr:`~gw_param`                    |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~gw_param_detectable`         |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lensed_param`                |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lensed_param_detectable`     |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~gw_param_sampler_dict`       |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lensed_param_sampler_dict`   |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~snr_calculator_dict`         |`dict`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~z_to_Dc`                     |`scipy.interpolate.interp1d`      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~Dc_to_z`                     |`scipy.interpolate.interp1d`      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~z_to_luminosity_distance`    |`scipy.interpolate.interp1d`      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~differential_comoving_volume`|`scipy.interpolate.interp1d`      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~compact_binary_pop`          |`CompactBinaryPopulation class`   |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lens_galaxy_pop`             |`LensGalaxyPopulation class`      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    | :attr:`~snr`                        |``gwsnr`` `package`               |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>

<span class="sd">    Instance Methods</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following method(s), \n</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    | Method(s)                          | Description                         |</span>
<span class="sd">    +====================================+=====================================+</span>
<span class="sd">    |:meth:`~gwsnr_intialization`        |Function for initializing the        |</span>
<span class="sd">    |                                    |``gwsnr`` package.                   |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~create_lookup_tables`       |To creating lookup tables for fast   |</span>
<span class="sd">    |                                    |calculation for the following        |</span>
<span class="sd">    |                                    |conversion operations,               |</span>
<span class="sd">    |                                    |redshift to co-moving distance.      |</span>
<span class="sd">    |                                    |co-moving distance to redshift.      |</span>
<span class="sd">    |                                    |redshift to luminosity distance.     |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~unlensed_cbc_statistics`    |Function to generate unlensed GW     |</span>
<span class="sd">    |                                    |source parameters.                   |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~unlensed_rate`              |Function to calculate unlensed       |</span>
<span class="sd">    |                                    |merger rate.                         |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~lensed_cbc_statistics`      |Function to generate lensed GW       |</span>
<span class="sd">    |                                    |source parameters.                   |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~lensed_rate`                |Function to calculate lensed         |</span>
<span class="sd">    |                                    |merger rate.                         |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~batch_handler`              |Function to handle the batch size.   |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>
<span class="sd">    |:meth:`~store_ler_params`           |Fuction to store the parameters of   |</span>
<span class="sd">    |                                    |the LER model.                       |</span>
<span class="sd">    +------------------------------------+-------------------------------------+</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Attributes</span>
<div class="viewcode-block" id="LeR.gw_param_sampler_dict"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.gw_param_sampler_dict">[docs]</a>    <span class="n">gw_param_sampler_dict</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    dictionary of params for initializing ``CompactBinaryPopulation`` class \n</span>
<span class="sd">    this will be used for GW unlensed parameters sampling \n</span>
<span class="sd">    gw_param_sampler_dict.keys() = [&#39;nsamples&#39;, &#39;m_min&#39;, &#39;m_max&#39;, &#39;z_min&#39;, &#39;z_max&#39;, &#39;event_type&#39;, &#39;src_model_params&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.lensed_param_sampler_dict"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_param_sampler_dict">[docs]</a>    <span class="n">lensed_param_sampler_dict</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    dictionary of params for initializing ``LensGalaxyPopulation`` class \n</span>
<span class="sd">    this will be used for GW lensed parameters sampling \n</span>
<span class="sd">    lensed_param_sampler_dict.keys() = [&#39;nsamples&#39;, &#39;min_lensed_images&#39;, &#39;max_lensed_images&#39;, &#39;lensModelList&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.snr_calculator_dict"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.snr_calculator_dict">[docs]</a>    <span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    dictionary of params for initializing ``snr_calculator`` (``gwsnr``) class \n</span>
<span class="sd">    this will be used for SNR calculation \n</span>
<span class="sd">    snr_calculator_dict.keys() = [&#39;mtot_min&#39;, &#39;mtot_max&#39;, &#39;nsamples_mtot&#39;, &#39;nsamples_mass_ratio&#39;, &#39;sampling_frequency&#39;, &#39;waveform_approximant&#39;, &#39;minimum_frequency&#39;, &#39;snr_type&#39;, &#39;waveform_inspiral_must_be_above_fmin&#39;, &#39;psds&#39;, &#39;psd_file&#39;, &#39;ifos&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.z_to_Dc"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.z_to_Dc">[docs]</a>    <span class="n">z_to_Dc</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``scipy.interpolate.interp1d`` \n</span>
<span class="sd">    redshift to co-moving distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.Dc_to_z"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.Dc_to_z">[docs]</a>    <span class="n">Dc_to_z</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``scipy.interpolate.interp1d`` \n</span>
<span class="sd">    co-moving distance to redshift.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.z_to_luminosity_distance"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.z_to_luminosity_distance">[docs]</a>    <span class="n">z_to_luminosity_distance</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``scipy.interpolate.interp1d`` \n</span>
<span class="sd">    redshift to luminosity distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.differential_comoving_volume"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.differential_comoving_volume">[docs]</a>    <span class="n">differential_comoving_volume</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``scipy.interpolate.interp1d`` \n</span>
<span class="sd">    differential comoving volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.compact_binary_pop"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.compact_binary_pop">[docs]</a>    <span class="n">compact_binary_pop</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``CompactBinaryPopulation class`` \n</span>
<span class="sd">    class for sampling GW parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.lens_galaxy_pop"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lens_galaxy_pop">[docs]</a>    <span class="n">lens_galaxy_pop</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``LensGalaxyPopulation class`` \n</span>
<span class="sd">    class for sampling lensed GW parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.snr"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.snr">[docs]</a>    <span class="n">snr</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;``gwsnr package`` \n</span>
<span class="sd">    class for calculating SNR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
        <span class="n">npool</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">z_min</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">z_max</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">25000</span><span class="p">,</span>
        <span class="n">snr_finder</span><span class="o">=</span><span class="s2">&quot;gwsnr&quot;</span><span class="p">,</span>
        <span class="n">json_file_ler_param</span><span class="o">=</span><span class="s2">&quot;./LeR_params.json&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">=</span> <span class="n">z_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="n">z_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npool</span> <span class="o">=</span> <span class="n">npool</span>
        <span class="c1"># batch size for parameters sampling and snr calculation</span>
        <span class="c1"># try keeping it below 50000</span>
        <span class="c1"># reduce the batch size if you are getting memory error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_detectable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_detectable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span> <span class="o">=</span> <span class="n">json_file_ler_param</span>

        <span class="c1"># dictionary of params for sampler</span>
        <span class="c1"># for unlened case (source params)</span>
        <span class="c1"># defualt for &#39;src_model_params&#39; is set for popI_II PowerLaw+PEAK model</span>
        <span class="c1"># for other models, please change the &#39;src_model_params&#39; accordingly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nsamples&quot;</span><span class="p">:</span> <span class="n">nsamples</span><span class="p">,</span>
            <span class="s2">&quot;m_min&quot;</span><span class="p">:</span> <span class="mf">4.59</span><span class="p">,</span>
            <span class="s2">&quot;m_max&quot;</span><span class="p">:</span> <span class="mf">86.22</span><span class="p">,</span>
            <span class="s2">&quot;z_min&quot;</span><span class="p">:</span> <span class="n">z_min</span><span class="p">,</span>
            <span class="s2">&quot;z_max&quot;</span><span class="p">:</span> <span class="n">z_max</span><span class="p">,</span>
            <span class="s2">&quot;event_type&quot;</span><span class="p">:</span> <span class="s2">&quot;BBH&quot;</span><span class="p">,</span>
            <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="s2">&quot;popI_II&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sub_category&quot;</span><span class="p">:</span> <span class="s2">&quot;gwcosmo&quot;</span><span class="p">,</span>
            <span class="s2">&quot;redshift_event_type&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;redshift_category&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;merger_rate_density_fn&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;merger_rate_density_param&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;src_model_params&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;mass_constant&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;redshift_constant&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;spin_constant&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># for lensed case</span>
        <span class="c1"># set &#39;min_lensed_images&#39; = 2 for double image lensed case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nsamples&quot;</span><span class="p">:</span> <span class="n">nsamples</span><span class="p">,</span>
            <span class="s2">&quot;min_lensed_images&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s2">&quot;max_lensed_images&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s2">&quot;lensModelList&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;EPL_NUMBA&quot;</span><span class="p">,</span> <span class="s2">&quot;SHEAR&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="c1"># for snr_calculator</span>
        <span class="c1"># for &#39;waveform_approximant&#39; other than IMRPhenomD or TaylorF2, please set &#39;snr_type&#39; = &#39;inner_product&#39;</span>
        <span class="c1"># you will get accurate results if you set &#39;nsamples_mtot&#39;: 200, &#39;nsamples_mass_ratio&#39;: 500., &#39;sampling_frequency&#39;: 4096.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;mtot_min&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>
            <span class="s2">&quot;mtot_max&quot;</span><span class="p">:</span> <span class="mf">439.6</span><span class="p">,</span>
            <span class="s2">&quot;nsamples_mtot&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
            <span class="s2">&quot;nsamples_mass_ratio&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;sampling_frequency&quot;</span><span class="p">:</span> <span class="mf">2048.0</span><span class="p">,</span>
            <span class="s2">&quot;waveform_approximant&quot;</span><span class="p">:</span> <span class="s2">&quot;IMRPhenomD&quot;</span><span class="p">,</span>
            <span class="s2">&quot;minimum_frequency&quot;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>
            <span class="s2">&quot;snr_type&quot;</span><span class="p">:</span> <span class="s2">&quot;interpolation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;waveform_inspiral_must_be_above_fmin&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;psds&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;psd_file&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;ifos&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;interpolator_dir&quot;</span><span class="p">:</span> <span class="s2">&quot;./interpolator_pickle&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># update dict from kwargs</span>
        <span class="n">keys1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">keys2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">keys3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># initialization of clasess, for both  CompactBinaryPopulation and LensGalaxyPopulation</span>
        <span class="c1"># CompactBinaryPopulation already inherits from Source_Galaxy_Population_Model class form source_population.py</span>
        <span class="c1"># LensGalaxyPopulation already inherits from Lens_Galaxy_Population_Model class form lens_galaxy_population.py</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_initialization</span><span class="p">()</span>

        <span class="c1"># initializing function for fast SNR calculation (in case of gwsnr)</span>
        <span class="k">if</span> <span class="n">snr_finder</span> <span class="o">==</span> <span class="s2">&quot;gwsnr&quot;</span><span class="p">:</span>
            <span class="c1"># default</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gwsnr_intialization</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># custom SNR function</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input your custom SNR finder function.</span><span class="se">\n</span><span class="s2"> self.snr=custom(gw_param_dict) .</span><span class="se">\n</span><span class="s2"> For details see the documentation.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># extra note on how to change snr finder function</span>
        <span class="c1"># self.snr = custom_snr_finder_function()</span>

        <span class="c1"># Create lookup tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_lookup_tables</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">store_ler_params</span><span class="p">(</span><span class="n">json_file</span><span class="o">=</span><span class="n">json_file_ler_param</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Attributes</span>
    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.gw_param"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.gw_param">[docs]</a>    <span class="k">def</span> <span class="nf">gw_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``bool``, ``dict`` \n</span>
<span class="sd">        gw_param is a dictionary of unlensed parameters (source parameters) \n</span>
<span class="sd">        it will be populated when unlened_cbc_statistics() is called \n</span>
<span class="sd">        if unavailable, the unlensed parameters will be sampled when unlensed_rate() is called \n</span>
<span class="sd">        gw_param.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;] \n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if file name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gw_param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gw_param</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param</span></div>

    <span class="nd">@gw_param</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gw_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.gw_param_detectable"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.gw_param_detectable">[docs]</a>    <span class="k">def</span> <span class="nf">gw_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``bool``, ``dict`` \n</span>
<span class="sd">        gw_param_detectable is a dictionary of unlensed parameters (source parameters) \n</span>
<span class="sd">        it will be populated when unlened_cbc_statistics() is called \n</span>
<span class="sd">        if unavailable, the unlensed parameters will be sampled when unlensed_rate() is called \n</span>
<span class="sd">        gw_param_detectable.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;] \n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if file name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gw_param_detectable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gw_param_detectable</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param_detectable</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param_detectable</span></div>

    <span class="nd">@gw_param_detectable</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gw_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gw_param_detectable</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.lensed_param"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_param">[docs]</a>    <span class="k">def</span> <span class="nf">lensed_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``bool``, ``dict`` \n</span>
<span class="sd">        lensed_param is a dictionary of lensed parameters \n</span>
<span class="sd">        it will be populated when lensed_cbc_statistics() is called \n</span>
<span class="sd">        if unavailable, the lensed parameters will be sampled when lensed_rate() is called \n</span>
<span class="sd">        lensed_param.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;lensed_images&#39;] \n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if file name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param</span></div>

    <span class="nd">@lensed_param</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lensed_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.lensed_param_detectable"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_param_detectable">[docs]</a>    <span class="k">def</span> <span class="nf">lensed_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``bool``, ``dict`` \n</span>
<span class="sd">        lensed_param_detectable is a dictionary of lensed parameters \n</span>
<span class="sd">        it will be populated when lensed_cbc_statistics() is called \n</span>
<span class="sd">        if unavailable, the lensed parameters will be sampled when lensed_rate() is called \n</span>
<span class="sd">        lensed_param_detectable.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;lensed_images&#39;] \n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if file name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param_detectable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param_detectable</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param_detectable</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param_detectable</span></div>

    <span class="nd">@lensed_param_detectable</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lensed_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lensed_param_detectable</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># CompactBinaryPopulation class and LensGalaxyPopulation class initialization</span>
<div class="viewcode-block" id="LeR.class_initialization"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.class_initialization">[docs]</a>    <span class="k">def</span> <span class="nf">class_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for initializing the ``CompactBinaryPopulation`` and ``LensGalaxyPopulation`` classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span> <span class="o">=</span> <span class="n">CompactBinaryPopulation</span><span class="p">(</span>
            <span class="n">z_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span>
            <span class="n">z_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">,</span>
            <span class="n">m_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;m_min&quot;</span><span class="p">],</span>
            <span class="n">m_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;m_max&quot;</span><span class="p">],</span>
            <span class="n">event_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;event_type&quot;</span><span class="p">],</span>
            <span class="n">category</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">],</span>
            <span class="n">sub_category</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;sub_category&quot;</span><span class="p">],</span>
            <span class="n">redshift_event_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;redshift_event_type&quot;</span><span class="p">],</span>
            <span class="n">redshift_category</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;redshift_category&quot;</span><span class="p">],</span>
            <span class="n">merger_rate_density_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span>
                <span class="s2">&quot;merger_rate_density_fn&quot;</span><span class="p">],</span>
            <span class="n">merger_rate_density_param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span>
                <span class="s2">&quot;merger_rate_density_param&quot;</span><span class="p">],</span>
            <span class="n">src_model_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;src_model_params&quot;</span><span class="p">],</span>
            <span class="n">mass_constant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;mass_constant&quot;</span><span class="p">],</span>
            <span class="n">redshift_constant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;redshift_constant&quot;</span><span class="p">],</span>
            <span class="n">spin_constant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;spin_constant&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_galaxy_pop</span> <span class="o">=</span> <span class="n">LensGalaxyPopulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LeR.store_ler_params"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.store_ler_params">[docs]</a>    <span class="k">def</span> <span class="nf">store_ler_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_file</span><span class="o">=</span><span class="s2">&quot;./LeR_params.json&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fuction to store the parameters of the LER model. This is useful for reproducing the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store gw_param_sampler_dict, lensed_param_sampler_dict and snr_calculator_dict</span>
        <span class="n">parameters_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># cbc params</span>
        <span class="n">gw_param_sampler_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;merger_rate_density_fn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span>
            <span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;merger_rate_density_fn&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">parameters_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;gw_param_sampler_dict&quot;</span><span class="p">:</span> <span class="n">gw_param_sampler_dict</span><span class="p">})</span>

        <span class="c1"># lensed params</span>
        <span class="n">parameters_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;lensed_param_sampler_dict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># snr calculator params</span>
        <span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s2">&quot;ifos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s2">&quot;ifos&quot;</span><span class="p">])</span>
        <span class="n">parameters_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;snr_calculator_dict&quot;</span><span class="p">:</span> <span class="n">snr_calculator_dict</span><span class="p">})</span>

        <span class="n">file_name</span> <span class="o">=</span> <span class="n">json_file</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">parameters_dict</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LeR.gwsnr_intialization"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.gwsnr_intialization">[docs]</a>    <span class="k">def</span> <span class="nf">gwsnr_intialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for initializing the `gwsnr &lt;https://github.com/hemantaph/gwsnr/&gt;`_ package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs_dict : &#39;dict&#39;</span>
<span class="sd">            keyword arguments for the initialization of the `gwsnr` package.</span>
<span class="sd">            kwargs_dict.keys() \n</span>
<span class="sd">            ``nsamples_mtot`` : `int`</span>
<span class="sd">                nsamples_mtot = 200 (recommended for accurate results)</span>
<span class="sd">            ``nsamples_mass_ratio`` : `int`</span>
<span class="sd">                nsamples_mass_ratio = 500 (recommended for accurate results)</span>
<span class="sd">            ``sampling_frequency`` : `float`</span>
<span class="sd">                sampling_frequency = 4096. (recommended for accurate results)</span>
<span class="sd">            ``waveform_approximant`` : `str`</span>
<span class="sd">                waveform_approximant = &quot;IMRPhenomD&quot; (for BBH) or &quot;TaylorF2&quot; (for BNS)</span>
<span class="sd">                if you want to use other approximants, please set ``snr_type`` = &#39;inner_product&#39;</span>
<span class="sd">            ``minimum_frequency`` : `float`</span>
<span class="sd">                minimum_frequency = 20. (for O3 and O4 runs) or 10. (for 3G detectors)</span>
<span class="sd">            ``snr_type`` : `str`</span>
<span class="sd">                snr_type = &#39;interpolation&#39; (for fast results) or &#39;inner_product&#39; (for bilby like results)</span>
<span class="sd">            ``waveform_inspiral_must_be_above_fmin`` : `bool`</span>
<span class="sd">                False if dont want minimum frequency cut-off as higher mass BBH can merger below that frequency.</span>
<span class="sd">            ``psds`` : `bool` or `dict` or `str` (txt file)</span>
<span class="sd">                e.g. For O4 design sensitivity \n</span>
<span class="sd">                    psds = {&#39;L1&#39;:&#39;aLIGOaLIGODesignSensitivityT1800044&#39;,\n</span>
<span class="sd">                    &#39;H1&#39;:&#39;aLIGOaLIGODesignSensitivityT1800044&#39;,\n</span>
<span class="sd">                    &#39;V1&#39;:&#39;AdvVirgo&#39;}</span>
<span class="sd">            ``psd_file`` : `bool`, `list`</span>
<span class="sd">                psd_file = False (if ASD) or True (if PSD file)</span>
<span class="sd">                psd_file = [False,True] if psds[0] is a asd and psds[1] is a psd</span>
<span class="sd">            ``ifos`` : `list`</span>
<span class="sd">                interferometer object name list</span>
<span class="sd">                ifos = [&#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;] (for O4 design sensitivity)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_ : `the gwsnr object`</span>
<span class="sd">            gwsnr object is used to calculate the SNR and pdet (probability of detection)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gwsnr_param_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span>

        <span class="c1"># update initialization dict from kwargs</span>
        <span class="n">keys_</span> <span class="o">=</span> <span class="n">gwsnr_param_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_</span><span class="p">:</span>
                <span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="n">snr_</span> <span class="o">=</span> <span class="n">GWSNR</span><span class="p">(</span>
            <span class="n">npool</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">,</span>
            <span class="n">mtot_min</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;mtot_min&quot;</span><span class="p">],</span>
            <span class="n">mtot_max</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;mtot_max&quot;</span><span class="p">],</span>
            <span class="n">nsamples_mtot</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;nsamples_mtot&quot;</span><span class="p">],</span>
            <span class="n">nsamples_mass_ratio</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;nsamples_mass_ratio&quot;</span><span class="p">],</span>
            <span class="n">sampling_frequency</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;sampling_frequency&quot;</span><span class="p">],</span>
            <span class="n">waveform_approximant</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;waveform_approximant&quot;</span><span class="p">],</span>
            <span class="n">minimum_frequency</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;minimum_frequency&quot;</span><span class="p">],</span>
            <span class="n">snr_type</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;snr_type&quot;</span><span class="p">],</span>
            <span class="n">waveform_inspiral_must_be_above_fmin</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span>
                <span class="s2">&quot;waveform_inspiral_must_be_above_fmin&quot;</span>
            <span class="p">],</span>
            <span class="n">psds</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;psds&quot;</span><span class="p">],</span>
            <span class="n">psd_file</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;psd_file&quot;</span><span class="p">],</span>
            <span class="n">ifos</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;ifos&quot;</span><span class="p">],</span>
            <span class="n">interpolator_dir</span><span class="o">=</span><span class="n">gwsnr_param_dict</span><span class="p">[</span><span class="s2">&quot;interpolator_dir&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">snr_</span></div>

<div class="viewcode-block" id="LeR.create_lookup_tables"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.create_lookup_tables">[docs]</a>    <span class="k">def</span> <span class="nf">create_lookup_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To creating lookup tables for fast calculation for the following conversion operations,</span>

<span class="sd">        #. redshift to co-moving distance.</span>
<span class="sd">        #. co-moving distance to redshift.</span>
<span class="sd">        #. redshift to luminosity distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z_min : `float`</span>
<span class="sd">            minimum redshift.</span>
<span class="sd">            for popI_II, popIII, primordial, BNS z_min = 0., 5., 5., 0. respectively.</span>
<span class="sd">        z_max : `float`</span>
<span class="sd">            maximum redshift.</span>
<span class="sd">            for popI_II, popIII, primordial, BNS z_max = 10., 40., 40., 2. respectively.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        z_to_Dc : `scipy.interpolate.interp1d`</span>
<span class="sd">            redshift to co-moving distance.</span>
<span class="sd">        Dc_to_z : `scipy.interpolate.interp1d`</span>
<span class="sd">            co-moving distance to redshift.</span>
<span class="sd">        z_to_luminosity_distance : `scipy.interpolate.interp1d`</span>
<span class="sd">            redshift to luminosity distance.</span>
<span class="sd">        differential_comoving_volume : `scipy.interpolate.interp1d`</span>
<span class="sd">            differential comoving volume.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialing cosmological functions for fast calculation through interpolation</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>  <span class="c1"># red-shifts</span>
        <span class="c1"># co-moving distance in Mpc</span>
        <span class="n">Dc</span> <span class="o">=</span> <span class="n">Planck18</span><span class="o">.</span><span class="n">comoving_distance</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="c1"># luminosity distance in Mpc</span>
        <span class="n">luminosity_distance</span> <span class="o">=</span> <span class="n">Planck18</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># generating interpolators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_to_Dc</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">Dc</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dc_to_z</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">Dc</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_to_luminosity_distance</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">luminosity_distance</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>

        <span class="c1"># Lookup table for differential comoving distance</span>
        <span class="n">differential_comoving_volume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Planck18</span><span class="o">.</span><span class="n">differential_comoving_volume</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="p">)</span>  <span class="c1"># differential comoving volume in Mpc^3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">differential_comoving_volume</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">differential_comoving_volume</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LeR.batch_handler"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.batch_handler">[docs]</a>    <span class="k">def</span> <span class="nf">batch_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">sampling_routine</span><span class="p">,</span> <span class="n">json_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to handle the batch size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">        sampling_routine : `function`</span>
<span class="sd">            function to sample the parameters.</span>
<span class="sd">            e.g. unlensed_sampling_routine() or lensed_sampling_routine()</span>
<span class="sd">        json_file : `str`</span>
<span class="sd">            name of the json file to store the parameters.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            if True, it will resume the sampling from the last batch.</span>
<span class="sd">            default resume = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="c1"># if nsamples is multiple of batch_size</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_batches</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">//</span> <span class="n">batch_size</span>
        <span class="c1"># if nsamples is not multiple of batch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_batches</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">//</span> <span class="n">batch_size</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;chosen batch size = </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">. If you want to change batch size, self.batch_size = new_size&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There will be </span><span class="si">{</span><span class="n">num_batches</span><span class="si">}</span><span class="s2"> batche(s)&quot;</span><span class="p">)</span>

        <span class="c1"># note frac_batches+(num_batches-1)*batch_size = nsamples</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="o">&gt;</span> <span class="n">batch_size</span><span class="p">:</span>
            <span class="n">frac_batches</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_batches</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span>
        <span class="c1"># if nsamples is less than batch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_batches</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="n">track_batches</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">track_batches</span> <span class="o">=</span> <span class="n">track_batches</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch no. </span><span class="si">{</span><span class="n">track_batches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># new first batch with the frac_batches</span>
            <span class="n">sampling_routine</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">frac_batches</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">json_file</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check where to resume from</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;resuming from </span><span class="si">{</span><span class="n">json_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">track_batches</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">frac_batches</span><span class="p">)</span> <span class="o">//</span> <span class="n">batch_size</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">track_batches</span> <span class="o">=</span> <span class="n">track_batches</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch no. </span><span class="si">{</span><span class="n">track_batches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># new first batch with the frac_batches</span>
                <span class="n">sampling_routine</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">frac_batches</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">json_file</span><span class="p">)</span>

        <span class="c1"># ---------------------------------------------------#</span>
        <span class="n">min_</span><span class="p">,</span> <span class="n">max_</span> <span class="o">=</span> <span class="n">track_batches</span><span class="p">,</span> <span class="n">num_batches</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_</span><span class="p">,</span> <span class="n">max_</span><span class="p">):</span>
            <span class="n">track_batches</span> <span class="o">=</span> <span class="n">track_batches</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch no. </span><span class="si">{</span><span class="n">track_batches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sampling_routine</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">json_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ---------------------------------------------------#</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LeR.unlensed_sampling_routine"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.unlensed_sampling_routine">[docs]</a>    <span class="k">def</span> <span class="nf">unlensed_sampling_routine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate unlensed GW source parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default nsamples = 100000.</span>
<span class="sd">        file_name : `str`</span>
<span class="sd">            name of the json file to store the parameters.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            if True, it will resume the sampling from the last batch.</span>
<span class="sd">            default resume = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get gw params</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling gw source params...&quot;</span><span class="p">)</span>
        <span class="n">gw_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span><span class="o">.</span><span class="n">sample_gw_parameters</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="c1"># Get all of the signal to noise ratios</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating snrs...&quot;</span><span class="p">)</span>
        <span class="n">snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="o">.</span><span class="n">snr</span><span class="p">(</span><span class="n">GWparam_dict</span><span class="o">=</span><span class="n">gw_param</span><span class="p">)</span>
        <span class="n">gw_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>

        <span class="c1"># store all params in json file</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">dictionary</span><span class="o">=</span><span class="n">gw_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="n">resume</span><span class="p">))</span>
        <span class="n">gw_param</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to free memory</span></div>

<div class="viewcode-block" id="LeR.unlensed_cbc_statistics"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.unlensed_cbc_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">unlensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">json_file</span><span class="o">=</span><span class="s2">&quot;./gw_params.json&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate unlensed GW source parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default nsamples = 100000.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        json_file : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default json_file = &#39;./gw_params.json&#39;.</span>
<span class="sd">        kwargs : `dict`</span>
<span class="sd">            key word arguments for initializing the ``CompactBinaryPopulation`` class. \n</span>
<span class="sd">            This initialization is either done at the time of class initialization or at the time of calling this function. \n</span>
<span class="sd">            Following parameters can be provided, \n</span>
<span class="sd">            ``m_min`` : `float`</span>
<span class="sd">                minimum mass of the compact binary (single).</span>
<span class="sd">            ``m_max`` : `float`</span>
<span class="sd">                maximum mass of the compact binary (single).</span>
<span class="sd">            ``event_type`` : `str`</span>
<span class="sd">                event_type = &#39;popI_II&#39; or `popIII` or `primordial`.</span>
<span class="sd">            ``src_model_params`` : `dict`</span>
<span class="sd">                src_model_params = {&#39;alpha&#39;: 3.63, &#39;beta&#39;: 1.26, &#39;delta_m&#39;: 4.82,\n</span>
<span class="sd">                &#39;mmin&#39;: 4.59, &#39;mmax&#39;: 86.22, &#39;lambda_peak&#39;: 0.08,\n</span>
<span class="sd">                &#39;mu_g&#39;: 33.07, &#39;sigma_g&#39;: 5.69}}</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_gw_params : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">            unlensed_gw_params.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gw_sampler_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span>

        <span class="c1"># gw parameter sampling</span>
        <span class="k">if</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="n">gw_sampler_dict</span><span class="p">[</span><span class="s2">&quot;nsamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="n">gw_sampler_dict</span><span class="p">[</span><span class="s2">&quot;nsamples&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if kwargs is empty</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">gw_sampler_dict</span><span class="p">:</span>
                        <span class="n">gw_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="c1"># re-initializing classes with new params</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">class_initialization</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># sampling in batches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">,</span>
            <span class="n">json_file</span><span class="o">=</span><span class="n">json_file</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">gw_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gw_param</span></div>

<div class="viewcode-block" id="LeR.unlensed_rate"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.unlensed_rate">[docs]</a>    <span class="k">def</span> <span class="nf">unlensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gw_param</span><span class="o">=</span><span class="s2">&quot;./gw_params.json&quot;</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">jsonfile</span><span class="o">=</span><span class="s2">&quot;./gw_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate unlensed merger rate.</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_U = \\mathcal{N}^U\\int dz_s R_o^U(z_s)\\bigg\\{\\Theta[\\rho(z_s,\\theta)-\\rho_{th}] P(\\theta) d\\theta \\bigg\\}</span>

<span class="sd">        - where :math:`\\mathcal{N}^U` is the normalization factor of the unlensed merger rate distribution wrt redshift.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gw_param : `dict` or `str` for json file name.</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">            default gw_param = &#39;./gw_params.json&#39;.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            SNR threshold for detection.</span>
<span class="sd">            default snr_threshold = 8.</span>
<span class="sd">        jsonfile : `str`</span>
<span class="sd">            json file name for storing the detectable parameters.</span>
<span class="sd">            default jsonfile = &#39;./gw_params_detectable.json&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_rate : (`float`,`float`)</span>
<span class="sd">            unlensed merger rate in a year</span>
<span class="sd">            unlensed_rate[0] = total unlensed rate with step function</span>
<span class="sd">            unlensed_rate[1] = total unlensed rate with pdet function</span>
<span class="sd">        gw_param_detectable : `dict`</span>
<span class="sd">            dictionary of detectable unlensed GW source parameters.</span>
<span class="sd">            gw_param_detectable.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get gw params from json file if not provided</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gw_param</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;getting gw_params from json file </span><span class="si">{</span><span class="n">gw_param</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="n">gw_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">gw_param</span><span class="p">)</span>

        <span class="c1"># call json_file_ler_param and for adding the final results</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># if detectability_condition == &quot;step_function&quot; or snr is not None:</span>
        <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># get snr</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="n">gw_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># snr not provided</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;snr not provided in gw_param dict. Exiting...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            
            <span class="c1"># selecting only detectable</span>
            <span class="n">idx_detectable</span> <span class="o">=</span> <span class="n">snr</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span>
            
            <span class="c1"># montecarlo integration</span>
            <span class="c1"># The total rate is Eq. A4 of https://arxiv.org/pdf/2106.06303.pdf</span>
            <span class="c1"># R = C0 int Theta(rho-rhoc) p(z) p(theta) dtheta dz_s, where C0 = int R(zs)/(1+zs) dVc/dzs dzs is the normalization constant for p(z)</span>
            <span class="c1"># Thus R = C0 &lt;Theta(rho-rhoc)&gt;</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span><span class="o">.</span><span class="n">normalization_pdf_z</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">idx_detectable</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total unlensed rate (yr^-1) (with step function): </span><span class="si">{</span><span class="n">total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unlensed_rate_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if pdet is provided</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pdet</span> <span class="o">=</span> <span class="n">gw_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="n">gw_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pdet not provided in gw_param dict. Exiting...&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span>

            <span class="n">pdet</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">snr_threshold</span> <span class="o">-</span> <span class="n">snr</span><span class="p">)</span>
            <span class="n">gw_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet</span>

            <span class="c1"># selecting only detectable</span>
            <span class="n">idx_detectable</span> <span class="o">=</span> <span class="n">pdet</span> <span class="o">&gt;</span> <span class="mf">0.5</span>

            <span class="c1"># with pdet</span>
            <span class="c1"># montecarlo integration</span>
            <span class="c1"># The total rate is Eq. A4 of https://arxiv.org/pdf/2106.06303.pdf</span>
            <span class="c1"># R = C0 int pdet p(z) p(theta) dtheta dz_s, where C0 = int R(zs)/(1+zs) dVc/dzs dzs is the normalization constant for p(z)</span>
            <span class="c1"># Thus R = C0 &lt;pdet&gt;</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span><span class="o">.</span><span class="n">normalization_pdf_z</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total unlensed rate (yr^-1) (with pdet function): </span><span class="si">{</span><span class="n">total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unlensed_rate_pdet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">gw_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">gw_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">]</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable unlensed params in </span><span class="si">{</span><span class="n">jsonfile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">,</span> <span class="n">gw_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get the detectable params and return</span>
        <span class="n">gw_param_detectable</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">gw_param_detectable</span><span class="p">)</span></div>

<div class="viewcode-block" id="LeR.lensed_sampling_routine"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_sampling_routine">[docs]</a>    <span class="k">def</span> <span class="nf">lensed_sampling_routine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate lensed GW source parameters, lens galaxy parameters and image paramters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">        file_name : `str`</span>
<span class="sd">            name of the json file to store the parameters.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            if True, it will resume the sampling from the last batch.</span>
<span class="sd">            default resume = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get lensed params</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling lensed params...&quot;</span><span class="p">)</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_galaxy_pop</span><span class="o">.</span><span class="n">sample_lens_parameters</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="c1"># now get (strongly lensed) image paramters along with lens parameters</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_galaxy_pop</span><span class="o">.</span><span class="n">get_image_properties</span><span class="p">(</span>
            <span class="n">n_min_images</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;min_lensed_images&quot;</span><span class="p">],</span>
            <span class="n">n_max_images</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;max_lensed_images&quot;</span><span class="p">],</span>
            <span class="n">lens_parameters</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">lensModelList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;lensModelList&quot;</span><span class="p">],</span>
            <span class="n">npool</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Get all of the signal to noise ratios</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating snrs...&quot;</span><span class="p">)</span>
        <span class="n">snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_galaxy_pop</span><span class="o">.</span><span class="n">get_lensed_snrs</span><span class="p">(</span>
            <span class="n">snr_calculator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">,</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">n_max_images</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;max_lensed_images&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">lensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>

        <span class="c1"># store all params in json file</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span> <span class="n">dictionary</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="n">resume</span><span class="p">))</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to free up memory</span></div>

<div class="viewcode-block" id="LeR.lensed_cbc_statistics"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_cbc_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">lensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">json_file</span><span class="o">=</span><span class="s2">&quot;./lensed_params.json&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate lensed GW source parameters, lens galaxy parameters and image paramters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default nsamples = 100000.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        json_file : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default json_file = &#39;./lensed_params.json&#39;.</span>
<span class="sd">        kwargs : `dict`</span>
<span class="sd">            key word arguments for initializing the ``LensGalaxyPopulation`` class. \n</span>
<span class="sd">            This initialization is either done at the time of class initialization or at the time of calling this function. \n</span>
<span class="sd">            Following parameters can be provided, \n</span>
<span class="sd">            ``min_lensed_images`` : `int`</span>
<span class="sd">                minimum number of lensed images.</span>
<span class="sd">            ``max_lensed_images`` : `int`</span>
<span class="sd">                maximum number of lensed images.</span>
<span class="sd">            ``lensModelList`` : `list`</span>
<span class="sd">                list of lens models.</span>
<span class="sd">                e.g. lensModelList = [&#39;EPL_NUMBA&#39;, &#39;SHEAR&#39;].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            lensed_param.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;, &#39;Dl&#39;,</span>
<span class="sd">            &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;traces&#39;,</span>
<span class="sd">            &#39;determinants&#39;, &#39;image_type&#39;, &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lens_sampler_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_param_sampler_dict</span>

        <span class="c1"># if new paramteres are provided</span>
        <span class="k">if</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="n">lens_sampler_dict</span><span class="p">[</span><span class="s2">&quot;nsamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="n">lens_sampler_dict</span><span class="p">[</span><span class="s2">&quot;nsamples&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># check if kwargs is empty</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">lens_sampler_dict</span><span class="p">:</span>
                        <span class="n">lens_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># re-initializing classes with new params</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">class_initialization</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># gw_param will not be kept same as that of unlensed case. So, it is sampled newly</span>
        <span class="c1"># sampling in batches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">,</span>
            <span class="n">json_file</span><span class="o">=</span><span class="n">json_file</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span></div>

<div class="viewcode-block" id="LeR.lensed_rate"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.lensed_rate">[docs]</a>    <span class="k">def</span> <span class="nf">lensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="s2">&quot;./lensed_params.json&quot;</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">num_img</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">jsonfile</span><span class="o">=</span><span class="s2">&quot;./lensed_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">none_as_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate lensed merger rate.</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_L = \\mathcal{N}^L\\int dz_s R_o^L(z_s)\\bigg\\{\\Theta[\\rho(z_s,\\theta)-\\rho_{th}] P(\\theta) d\\theta \\bigg\\}</span>

<span class="sd">        - where :math:`\\mathcal{N}^L` is the normalization factor of the lensed merger rate distribution wrt redshift.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict` or `str` for the json file name.</span>
<span class="sd">            dictionary of lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            lensed_param.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;, &#39;Dl&#39;,</span>
<span class="sd">            &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;traces&#39;,</span>
<span class="sd">            &#39;determinants&#39;, &#39;image_type&#39;, &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = 8.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images.</span>
<span class="sd">            e.g. num_img = 2.</span>
<span class="sd">        jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default jsonfile = &#39;./lensed_params_detectable.json&#39;.</span>
<span class="sd">        none_as_nan : `bool`</span>
<span class="sd">            if True, replace None with np.nan in the lensed_param dictionary.</span>
<span class="sd">            default none_as_nan = True.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_rate : `float`</span>
<span class="sd">            lensed merger rate in a year.</span>
<span class="sd">            lensed_rate[0] = total lensed rate with step function</span>
<span class="sd">            lensed_rate[1] = total lensed rate with pdet function</span>
<span class="sd">        detectable_lensed_param : `dict`</span>
<span class="sd">            dictionary of detectable lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            detectable_lensed_param.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;,</span>
<span class="sd">            &#39;Dl&#39;, &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;traces&#39;,</span>
<span class="sd">            &#39;determinants&#39;, &#39;image_type&#39;, &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get lensed params from json file if not provided</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;getting lensed_param from json file </span><span class="si">{</span><span class="n">lensed_param</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">)</span>

        <span class="c1"># get size of the lensed_param for a parameter</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

        <span class="c1"># call json_file_ler_param and for adding the final results</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># check for images with snr above threshold</span>
        <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">snr_threshold</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">num_img</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># convert to array</span>

        <span class="c1"># weights=1 if set minimum number of image is 2</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
        <span class="c1"># rejection sample wrt to weights</span>
        <span class="n">not_rejected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">weights</span>

        <span class="c1"># if detectability_condition == &quot;step_function&quot; or snr is not None:</span>
        <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># get snr, dimensions are (nsamples, n_max_images)</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># snr not provided</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;snr not provided in lensed_param dict. Exiting...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># boolean array to store the result of the threshold condition</span>
            <span class="c1"># for each row: choose a threshold and check if the number of images above threshold. Sum over the images. If sum is greater than num_img, then snr_hit = True </span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">)):</span>
                <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">snr</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="n">not_rejected</span>

            <span class="c1"># montecarlo integration</span>
            <span class="c1"># The total rate is Eq. A4 of https://arxiv.org/pdf/2106.06303.pdf</span>
            <span class="c1"># R = C0 int Theta(rho-rhoc) p(z) p(theta) dtheta dz_s, where C0 = int R(zs)/(1+zs) dVc/dzs tau(zs) dzs is the normalization constant for p(z)</span>
            <span class="c1"># Thus R = C0 &lt;Theta(rho-rhoc)&gt;</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_galaxy_pop</span><span class="o">.</span><span class="n">normalization_pdf_z</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">snr_hit</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total lensed rate (yr^-1) (with step function): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">total_rate</span><span class="p">))</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;lensed_rate_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get pdet, dimensions are (nsamples, n_max_images)</span>
            <span class="c1"># check if pdet is provided</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pdet</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># dimensions are (nsamples, n_max_images)</span>
                    <span class="n">pdet</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">)):</span>
                        <span class="c1"># store pdet for each threshold condition</span>
                        <span class="n">pdet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">snr</span><span class="p">))</span>
                    <span class="n">pdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pdet not provided in lensed_param dict. Exiting...&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span>
                
            <span class="c1"># product of pdet for all images</span>
            <span class="c1"># think of 3d layer. x-y correspons to snr, and z wrt snr_threshold</span>
            <span class="n">pdet_combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">)):</span>
                <span class="c1"># sort pdet and use only num_img images</span>
                <span class="n">pdet_combined</span> <span class="o">=</span> <span class="n">pdet_combined</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">pdet</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_combined</span>

            <span class="c1"># snr_hit</span>
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">pdet_combined</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="n">not_rejected</span>

            <span class="c1"># with pdet</span>
            <span class="c1"># montecarlo integration</span>
            <span class="c1"># The total rate is Eq. A4 of https://arxiv.org/pdf/2106.06303.pdf</span>
            <span class="c1"># R = C0 int Theta(rho-rhoc) p(z) p(theta) dtheta dz_s, where C0 = int R(zs)/(1+zs) dVc/dzs tau(zs) dzs is the normalization constant for p(z)</span>
            <span class="c1"># Thus R = C0 &lt;pdet&gt;</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compact_binary_pop</span><span class="o">.</span><span class="n">normalization_pdf_z</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdet_combined</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total lensed rate (yr^-1) (with pdet function): </span><span class="si">{</span><span class="n">total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;lensed_rate_pdet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>

        <span class="c1"># store all params in json file</span>
        <span class="k">if</span> <span class="n">none_as_nan</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">snr_hit</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">snr_hit</span><span class="p">])</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable lensed params in </span><span class="si">{</span><span class="n">jsonfile</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># get the detectable params and return</span>
        <span class="n">lensed_param_detectable</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">lensed_param_detectable</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LeR.rate_comparision"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.rate_comparision">[docs]</a>    <span class="k">def</span> <span class="nf">rate_comparision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate unlensed and lensed merger rate and their ratio. </span>
<span class="sd">        It will get the unlensed_rate and lensed_rate from json_file_ler_param=&quot;./LeR_params.json&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition, either &quot;step_function&quot; or &quot;pdet_function&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unlensed_rate : `float`</span>
<span class="sd">            unlensed merger rate</span>
<span class="sd">        lensed_rate : `float`</span>
<span class="sd">            lensed merger rate</span>
<span class="sd">        ratio : `float`</span>
<span class="sd">            ratio of lensed_rate and unlensed_rate</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call json_file_ler_param and add the results</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unlensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unlensed_rate_step&#39;</span><span class="p">]</span>
                <span class="n">lensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;lensed_rate_step&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unlensed_rate_step or lensed_rate_step not found in json file. Exiting...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">rate_ratio</span> <span class="o">=</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rate_ratio_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>

        <span class="k">elif</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;pdet&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">unlensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;unlensed_rate_pdet&#39;</span><span class="p">]</span>
                <span class="n">lensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;lensed_rate_pdet&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unlensed_rate_pdet or lensed_rate_pdet not found in json file. Exiting...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">rate_ratio</span> <span class="o">=</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span>
            <span class="c1"># append the results</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rate_ratio_pdet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;detectability_condition should be either step_function or pdet_function&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unlensed_rate: </span><span class="si">{</span><span class="n">unlensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lensed_rate: </span><span class="si">{</span><span class="n">lensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio: </span><span class="si">{</span><span class="n">rate_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">unlensed_rate</span><span class="p">,</span> <span class="n">lensed_rate</span><span class="p">,</span> <span class="n">rate_ratio</span><span class="p">)</span></div>

<div class="viewcode-block" id="LeR.rate_comparision_with_rate_calculation"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.rate_comparision_with_rate_calculation">[docs]</a>    <span class="k">def</span> <span class="nf">rate_comparision_with_rate_calculation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">snr_threshold_unlensed</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">unlened_param</span><span class="o">=</span><span class="s2">&quot;./gw_params.json&quot;</span><span class="p">,</span>
        <span class="n">snr_threshold_lensed</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">num_img</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="s2">&quot;./lensed_params.json&quot;</span><span class="p">,</span>
        <span class="n">jsonfile_unlensed</span><span class="o">=</span><span class="s2">&quot;./gw_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">jsonfile_lensed</span><span class="o">=</span><span class="s2">&quot;./lensed_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate unlensed and lensed merger rate and their ratio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_threshold_unlensed : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio for unlensed case.</span>
<span class="sd">            e.g. snr_threshold_unlensed = 8.</span>
<span class="sd">        unlened_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">            unlened_param.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;]</span>
<span class="sd">        snr_threshold_lensed : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio for lensed case.</span>
<span class="sd">            e.g. snr_threshold_lensed = 8.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images crossing the threshold.</span>
<span class="sd">            e.g. num_img = 2.</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            lensed_param.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;, &#39;Dl&#39;,</span>
<span class="sd">            &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;traces&#39;,</span>
<span class="sd">            &#39;determinants&#39;, &#39;image_type&#39;, &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">        jsonfile_unlensed : `str`</span>
<span class="sd">            json file name for storing the parameters for unlensed detectable case.</span>
<span class="sd">            default jsonfile_unlensed = &#39;./gw_params_detectable.json&#39;.</span>
<span class="sd">        jsonfile_lensed : `str`</span>
<span class="sd">            json file name for storing the parameters for lensed detectable case.</span>
<span class="sd">            default jsonfile_lensed = &#39;./lensed_params_detectable.json&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_rate : (`float`,`float`)</span>
<span class="sd">            unlensed merger rate in a year</span>
<span class="sd">            unlensed_rate[0] = total unlensed rate with step function</span>
<span class="sd">            unlensed_rate[1] = total unlensed rate with pdet function</span>
<span class="sd">        lensed_rate : (`float`,`float`)</span>
<span class="sd">            lensed merger rate in a year</span>
<span class="sd">            lensed_rate[0] = total lensed rate with step function</span>
<span class="sd">            lensed_rate[1] = total lensed rate with pdet function</span>
<span class="sd">        rate_ratio : (`float`,`float`)</span>
<span class="sd">            unlensed/lensed rate ratio</span>
<span class="sd">            rate_ratio[0] = total unlensed/lensed rate ratio with step function</span>
<span class="sd">            rate_ratio[1] = total unlensed/lensed rate ratio with pdet function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate unlensed rate</span>
        <span class="c1"># print(f&#39;getting unlened_param from json file {unlened_param}...&#39;)</span>
        <span class="n">unlensed_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_rate</span><span class="p">(</span>
            <span class="n">gw_param</span><span class="o">=</span><span class="n">unlened_param</span><span class="p">,</span>
            <span class="n">snr_threshold</span><span class="o">=</span><span class="n">snr_threshold_unlensed</span><span class="p">,</span>
            <span class="n">jsonfile</span><span class="o">=</span><span class="n">jsonfile_unlensed</span><span class="p">,</span>
            <span class="n">detectability_condition</span><span class="o">=</span><span class="n">detectability_condition</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># calculate lensed rate</span>
        <span class="c1"># print(f&#39;getting lensed_param from json file {lensed_param}...&#39;)</span>
        <span class="n">lensed_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_rate</span><span class="p">(</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">snr_threshold</span><span class="o">=</span><span class="n">snr_threshold_lensed</span><span class="p">,</span>
            <span class="n">num_img</span><span class="o">=</span><span class="n">num_img</span><span class="p">,</span>
            <span class="n">jsonfile</span><span class="o">=</span><span class="n">jsonfile_lensed</span><span class="p">,</span>
            <span class="n">detectability_condition</span><span class="o">=</span><span class="n">detectability_condition</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># rate ratio</span>
        <span class="n">rate_ratio</span> <span class="o">=</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unlensed/lensed rate ratio = &quot;</span><span class="p">,</span> <span class="n">rate_ratio</span><span class="p">)</span>
        <span class="c1"># call json_file_ler_param and add the results</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># append the results</span>
        <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rate_ratio_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>
        <span class="k">elif</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;pdet&quot;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rate_ratio_pdet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>
        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_ler_param</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">unlensed_rate</span><span class="p">,</span> <span class="n">lensed_rate</span><span class="p">,</span> <span class="n">rate_ratio</span><span class="p">)</span></div>

    <span class="c1"># ---------------------------------------------------#</span>
    <span class="c1"># functions for selecting n lensed detectable events #</span>
    <span class="c1"># ---------------------------------------------------#</span>
<div class="viewcode-block" id="LeR.selecting_n_lensed_detectable_events"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.selecting_n_lensed_detectable_events">[docs]</a>    <span class="k">def</span> <span class="nf">selecting_n_lensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">num_img</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">json_file</span><span class="o">=</span><span class="s2">&quot;./lensed_params_detectable.json&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to select n lensed detectable events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples to be selected.</span>
<span class="sd">            default size = 100.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = 8. or [8.,6.]</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images crossing the threshold.</span>
<span class="sd">            e.g. num_img = 2 or [1,1]</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            if True, it will resume the sampling from the last batch.</span>
<span class="sd">            default resume = False.</span>
<span class="sd">        json_file : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default json_file = &#39;./lensed_params_detectable.json&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            param_final.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;,</span>
<span class="sd">            &#39;Dl&#39;, &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;image_type&#39;,</span>
<span class="sd">            &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">&gt;</span> <span class="mi">1000</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># iterator</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get sample size as nsamples from json file</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">param_final</span>

        <span class="n">buffer_file</span> <span class="o">=</span> <span class="s2">&quot;./lensed_params_buffer.json&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># Dimensions are (nsamples, n_max_images)</span>
                <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">buffer_file</span><span class="p">)</span>

                <span class="c1"># get snr</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span>

                <span class="c1"># dealing with snr_threshold and num_img</span>
                <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">snr_threshold</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="o">-</span><span class="mi">1</span>
                <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_img</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="o">-</span><span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># convert to array</span>
                <span class="c1"># sort in descending order of each row</span>
                <span class="n">arg_th</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">snr_threshold</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                <span class="n">sorted_snr</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">num1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># tracks the number of images for the current threshold</span>
                <span class="n">num2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># tracks the column number of the already sorted snr 2D array</span>
                <span class="c1"># boolean array to store the result of the threshold condition</span>
                <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arg_th</span><span class="p">:</span>
                    <span class="n">num1</span> <span class="o">=</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num1</span><span class="p">):</span>
                        <span class="c1"># snr_hit step function case</span>
                        <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sorted_snr</span><span class="p">[:,</span> <span class="n">num2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">num2</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">weights</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
                <span class="c1"># rejection sample wrt to weights</span>
                <span class="n">not_rejected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">weights</span>
                <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="n">not_rejected</span>

                <span class="c1"># store all params in json file</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">snr_hit</span><span class="p">])</span>
                <span class="n">append_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">snr_hit</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># trim the final param dictionary</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;trmming final result to size=</span><span class="si">{</span><span class="n">nsamples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
        <span class="c1"># trim the final param dictionary</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">]),</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_final</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># save the final param dictionary</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span></div>

<div class="viewcode-block" id="LeR.relative_mu_dt_lensed"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.relative_mu_dt_lensed">[docs]</a>    <span class="k">def</span> <span class="nf">relative_mu_dt_lensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="o">=</span><span class="p">[</span><span class="mf">8.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to classify the lensed images wrt to the morse phase difference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters, lens galaxy parameters and image paramters.</span>
<span class="sd">            lensed_param.keys() = [&#39;zl&#39;, &#39;zs&#39;, &#39;sigma&#39;, &#39;q&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;gamma1&#39;, &#39;gamma2&#39;, &#39;Dl&#39;,</span>
<span class="sd">            &#39;Ds&#39;, &#39;Dls&#39;, &#39;theta_E&#39;, &#39;gamma&#39;, &#39;mass_1&#39;, &#39;mass_2&#39;, &#39;mass_1_source&#39;, &#39;mass_2_source&#39;,</span>
<span class="sd">            &#39;luminosity_distance&#39;, &#39;iota&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;n_images&#39;,</span>
<span class="sd">            &#39;x0_image_positions&#39;, &#39;x1_image_positions&#39;, &#39;magnifications&#39;, &#39;time_delays&#39;, &#39;traces&#39;,</span>
<span class="sd">            &#39;determinants&#39;, &#39;image_type&#39;, &#39;weights&#39;, &#39;opt_snr_net&#39;, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = [8.,8.] or [8.,6.] for subthreshold</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        mu_rel0 : `float.array`</span>
<span class="sd">            relative magnification for 0 degree phase difference.</span>
<span class="sd">        dt_rel0 : `float.array`</span>
<span class="sd">            relative time delay for 0 degree phase difference.</span>
<span class="sd">        mu_rel90 : `float.array`</span>
<span class="sd">            relative magnification for 90 degree phase difference.</span>
<span class="sd">        dt_rel90 : `float.array`</span>
<span class="sd">            relative time delay for 90 degree phase difference.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get magnifications, time_delays and snr</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;magnifications&quot;</span><span class="p">])</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;time_delays&quot;</span><span class="p">])</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">])</span>

        <span class="c1"># for 0 degree phase difference</span>
        <span class="c1"># get the index of the image which cross the threshold</span>
        <span class="c1"># get snr_threshold sorted first in descending order</span>
        <span class="n">snr_threshold</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">))</span>
        <span class="c1"># for type I</span>
        <span class="n">snr1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># for type II</span>
        <span class="n">snr2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># checking for zero values</span>
        <span class="c1"># check for threshold condition</span>
        <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">idx1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">idx2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># combine magnifications and time_delays</span>
        <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mu</span><span class="p">[</span><span class="n">idx1</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">mu</span><span class="p">[</span><span class="n">idx2</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dt_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="n">idx1</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dt</span><span class="p">[</span><span class="n">idx2</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>  <span class="c1"># to days</span>

        <span class="c1"># relative magnification</span>
        <span class="n">mu_rel0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># relative time delay</span>
        <span class="n">dt_rel0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dt_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># for 90 degree phase difference</span>
        <span class="c1"># for type I</span>
        <span class="n">snr1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># for type II</span>
        <span class="n">snr2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># checking for zero values</span>
        <span class="c1"># check for threshold condition</span>
        <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">snr1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">idx1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">snr2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">idx2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># combine magnifications and time_delays</span>
        <span class="n">mu_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mu</span><span class="p">[</span><span class="n">idx1</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">mu</span><span class="p">[</span><span class="n">idx2</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dt_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="n">idx1</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dt</span><span class="p">[</span><span class="n">idx2</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>  <span class="c1"># in days</span>

        <span class="c1"># relative magnification</span>
        <span class="n">mu_rel90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mu_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># relative time delay</span>
        <span class="n">dt_rel90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dt_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">mu_rel0</span><span class="p">,</span> <span class="n">dt_rel0</span><span class="p">,</span> <span class="n">mu_rel90</span><span class="p">,</span> <span class="n">dt_rel90</span><span class="p">)</span></div>

<div class="viewcode-block" id="LeR.mu_vs_dt_plot"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.mu_vs_dt_plot">[docs]</a>    <span class="k">def</span> <span class="nf">mu_vs_dt_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_array</span><span class="p">,</span>
        <span class="n">y_array</span><span class="p">,</span>
        <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
        <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">5e2</span><span class="p">,</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span><span class="p">],</span>
        <span class="n">contour_levels</span><span class="o">=</span><span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.68</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate 2D KDE and plot the relative magnification vs time delay difference for lensed samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_array : `float.array`</span>
<span class="sd">            x array.</span>
<span class="sd">        y_array : `float.array`</span>
<span class="sd">            y array.</span>
<span class="sd">        xlabel : `str`</span>
<span class="sd">            x label.</span>
<span class="sd">        ylabel : `str`</span>
<span class="sd">            y label.</span>
<span class="sd">        title : `str`</span>
<span class="sd">            title.</span>
<span class="sd">        savefig : `bool`</span>
<span class="sd">            if True, it will save the figure.</span>
<span class="sd">            default savefig = False.</span>
<span class="sd">        ax : `matplotlib.axes`</span>
<span class="sd">            matplotlib axes.</span>
<span class="sd">            default ax = None.</span>
<span class="sd">        colors : `str`</span>
<span class="sd">            color of the plot.</span>
<span class="sd">            default colors = &#39;blue&#39;.</span>
<span class="sd">        linestyles : `str`</span>
<span class="sd">            linestyle of the plot.</span>
<span class="sd">            default linestyles = &#39;-&#39;.</span>
<span class="sd">        origin : `str`</span>
<span class="sd">            origin of the plot.</span>
<span class="sd">            default origin = &#39;upper&#39;.</span>
<span class="sd">        alpha : `float`</span>
<span class="sd">            alpha of the plot.</span>
<span class="sd">            default alpha = 0.6.</span>
<span class="sd">        extent : `list`</span>
<span class="sd">            extent of the plot.</span>
<span class="sd">            default extent = [1e-2,5e2,1e-2,1e2].</span>
<span class="sd">        contour_levels : `list`</span>
<span class="sd">            contour levels of the plot.</span>
<span class="sd">            default contour_levels = [0.10,0.40,0.68,0.95] which corresponds to 1,2,3,4 sigma.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># applying cutt-off</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">x_array</span> <span class="o">&gt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">x_array</span> <span class="o">&lt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_array</span> <span class="o">&gt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_array</span> <span class="o">&lt;</span> <span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">x_array</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">y_array</span> <span class="o">=</span> <span class="n">y_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">xu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x_array</span><span class="p">)</span>
        <span class="n">yu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y_array</span><span class="p">)</span>

        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">5e2</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">1e2</span><span class="p">)</span>

        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">,</span> <span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xu</span><span class="p">,</span> <span class="n">yu</span><span class="p">])</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kernel</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">zsort</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">ff</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="n">cumz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">zsort</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zsort</span><span class="p">)</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">cumz</span><span class="p">,</span> <span class="n">zsort</span><span class="p">)</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">contour_levels</span><span class="p">:</span>
            <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">levels</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">ff</span><span class="p">),</span>
            <span class="n">levels</span><span class="p">,</span>
            <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
            <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">extent</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$log_</span><span class="si">{10}</span><span class="s2">\Delta t$ (days)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Delta log_</span><span class="si">{10}</span><span class="s2">\mu$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;relative magnification vs relative time delay&quot;</span><span class="p">)</span>

        <span class="c1"># save figure</span>
        <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;mu_vs_dt.png&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="LeR.selecting_n_unlensed_detectable_events"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.selecting_n_unlensed_detectable_events">[docs]</a>    <span class="k">def</span> <span class="nf">selecting_n_unlensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">json_file</span><span class="o">=</span><span class="s2">&quot;./gw_params_detectable.json&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to select n unlensed detectable events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsamples : `int`</span>
<span class="sd">            number of samples to be selected.</span>
<span class="sd">            default size = 100.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = 8.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            if True, it will resume the sampling from the last batch.</span>
<span class="sd">            default resume = False.</span>
<span class="sd">        json_file : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default json_file = &#39;./gw_params_detectable.json&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">            param_final.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">&gt;</span> <span class="mi">1000</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># iterator</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get sample size as nsamples from json file</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">param_final</span>

        <span class="n">buffer_file</span> <span class="o">=</span> <span class="s2">&quot;./gw_params_buffer.json&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># get unlensed params</span>
                <span class="n">unlensed_param</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">buffer_file</span><span class="p">)</span>

                <span class="c1"># get snr</span>
                <span class="n">snr</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;opt_snr_net&quot;</span><span class="p">]</span>
                <span class="c1"># index of detectable events</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">snr</span> <span class="o">&gt;</span> <span class="n">snr_threshold</span>

                <span class="c1"># store all params in json file</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">unlensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">unlensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">append_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># trim the final param dictionary</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;trmming final result to size=</span><span class="si">{</span><span class="n">nsamples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
        <span class="c1"># trim the final param dictionary</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">]),</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_final</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># save the final param dictionary</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span></div>

<div class="viewcode-block" id="LeR.relative_mu_dt_unlensed"><a class="viewcode-back" href="../../autoapi/ler/ler/index.html#ler.LeR.relative_mu_dt_unlensed">[docs]</a>    <span class="k">def</span> <span class="nf">relative_mu_dt_unlensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate relative magnification vs time delay difference for unlensed samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">            unlensed_param.keys() = [&#39;m1&#39;, &#39;m2&#39;, &#39;z&#39;, &#39;snr&#39;, &#39;theta_jn&#39;, &#39;ra&#39;, &#39;dec&#39;, &#39;psi&#39;, &#39;phase&#39;, &#39;geocent_time&#39;]</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        dmu : `float.array`</span>
<span class="sd">            relative magnification.</span>
<span class="sd">        dt : `float.array`</span>
<span class="sd">            relative time delay.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;geocent_time&quot;</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="s2">&quot;luminosity_distance&quot;</span><span class="p">]</span>

        <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mu_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">len_</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">t_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">idx1</span><span class="p">])</span>
            <span class="n">mu_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">[</span><span class="n">idx1</span><span class="p">])</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span><span class="p">)</span>  <span class="c1"># in days</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mu_</span><span class="p">)))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">dmu</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Phurailatpam Hemantakumar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>